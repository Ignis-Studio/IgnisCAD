{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>[!TIP] This project is one of the THOUGHT OF THE DAY projects. \u8be5\u9879\u76ee\u662f\u201c\u6bcf\u65e5\u7075\u611f\u8bb0\u5f55\u201d\u7cfb\u5217\u9879\u76ee\u4e4b\u4e00\u3002 The development of these project may not be active. \u8fd9\u4e9b\u9879\u76ee\u7684\u5f00\u53d1\u53ef\u80fd\u4e0d\u4f1a\u6d3b\u8dc3\u3002 </p>"},{"location":"#igniscad","title":"IgnisCAD","text":"<p>\u4f7f\u7528 Python \u5c01\u88c5 build123d \u8fdb\u884c CAD \u5f00\u53d1\uff0c\u8ba9 AI \u667a\u80fd\u4f53\u53ef\u4ee5\u4f7f\u7528\u7eaf\u6587\u672c\u5efa\u6a21\u3002 A wrapper for the build123d library, designed for AI agents. </p>"},{"location":"#usage","title":"\u4f7f\u7528 Usage","text":"<p>\u4f7f\u7528 PyPI \u4e0b\u8f7d\u8be5\u5305\uff1a  Download the package via PyPI: <pre><code>python -m pip install igniscad\n</code></pre> \u7531\u4e8e\u9879\u76ee\u6b63\u5728\u5feb\u901f\u66f4\u65b0\uff0c\u56e0\u6b64\u4e0d\u5efa\u8bae\u60a8\u4f7f\u7528\u955c\u50cf\u6e90\u3002 Using mirror sources is not recommended due to the early developing of the project.</p>"},{"location":"#api","title":"API","text":"<p>\u6574\u4e2a\u9879\u76ee\u56f4\u7ed5 Entity \u7c7b\u6784\u9020\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 Model \u7c7b\u6765\u521b\u9020\u4e00\u4e2a\u6a21\u578b\uff0c\u5e76\u5728\u5176\u4e2d\u6dfb\u52a0\u548c\u6539\u9020 Entity\u3002 The whole project is based on the class Entity, you can create a model via calling the class Model,  and try adding or modifying some Entity inside it.</p> <p>\u6bcf\u4e2a Entity \u90fd\u662f\u4e00\u4e2a build123d \u7c7b\u5e93\u7684\u5c01\u88c5\uff0c\u6709\u4e9b\u662f\u7c7b\uff0c\u6709\u4e9b\u5219\u662f\u5de5\u5382\u51fd\u6570\u3002  Every Entity is a wrapper for build123d classes, which can be primitive functions or subclasses.</p> <p>\u6bcf\u4e2a Entity \u5728\u5b9a\u4e49\u65f6\u90fd\u6709\u4e00\u4e2a name \u5c5e\u6027\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7 name \u5c5e\u6027\u6765\u5728\u6a21\u578b\u4e2d\u5feb\u901f\u67e5\u627e\u4e00\u4e2a\u7279\u5b9a\u7684 Entity\u3002 Each Entity has a name property while defining,  you can use the name property to find a specified Entity in the model immediately. \u8fd9\u6837\u53ef\u4ee5\u4fdd\u8bc1\u4e0a\u4e0b\u6587\u7684\u7edf\u4e00\u6027\uff0c\u4e5f\u6709\u52a9\u4e8e\u8fdb\u884c\u539f\u5b50\u6027\u4fee\u6539\uff1a This ensures the consistency of context and facilitates atomic modifications: <pre><code>from igniscad import *\nwith Model(\"Example\") as model:\n    model &lt;&lt; Cylinder(5, 38, \"pole\")\n    model.find(\"pole\") # Returns the original Cylinder.\n</code></pre></p>"},{"location":"#charts","title":"\u56fe\u8868 Charts","text":""},{"location":"api/","title":"API Reference","text":""},{"location":"api/#igniscad","title":"<code>igniscad</code>","text":""},{"location":"api/#igniscad.AlignmentMixin","title":"<code>AlignmentMixin</code>","text":"<p>A mixin of class Entity, specified to calculate alignment, bounding box and position.</p> Source code in <code>src/igniscad/mixins.py</code> <pre><code>class AlignmentMixin:\n    \"\"\"\n    A mixin of class Entity, specified to calculate alignment, bounding box and position.\n    \"\"\"\n    # Syntactic properties\n    @property\n    def bbox(self):\n        \"\"\"Grabbing the bounding box of the entity.\"\"\"\n        if TYPE_CHECKING:\n            assert isinstance(self, Entity)\n        return self.wrap_result(self.part).bounding_box()\n\n    @property\n    def top(self):\n        \"\"\"Grabbing the Z pos of the center point of the top surface of the entity.\"\"\"\n        return self.bbox.max.Z\n\n    @property\n    def right(self):\n        \"\"\"Grabbing the maximum X pos.\"\"\"\n        return self.bbox.max.X\n\n    @property\n    def radius(self):\n        \"\"\"Estimate the radius of the entity(only for spheres and/or cylinders).\"\"\"\n        # Simple logic: Grabbing half the width in the X direction.\n        return self.bbox.size.X / 2\n\n    # Universal alignment (syntactic)\n    def align(self, target, face=\"top\", offset=0):\n        \"\"\"\n        *Snap* the current Entity to a specified face of the target.\n\n        Calculation:\n            Center pos of the target surface + Half of the current's thickness + Additional gap\n\n        Args:\n            target (Entity): The target Entity\n            face (str): \"top\", \"bottom\", \"left\", \"right\", \"front\", \"back\"\n            offset (float): Addition gap between the current and the target.\n                (A positive number refers to a gap and a negative number refers to an embedding.)\n        \"\"\"\n\n        # Grabbing the bounding box.\n        t_box = target.bbox  # Target Bounding Box\n        s_box = self.bbox  # Self Bounding Box (Current)\n\n        # The default goal pos is target.center().\n        dest_x = t_box.center().X\n        dest_y = t_box.center().Y\n        dest_z = t_box.center().Z\n\n        # Own size (Width, Depth, Height)\n        s_w = s_box.size.X\n        s_d = s_box.size.Y\n        s_h = s_box.size.Z\n\n        # Adjust the goal pos according to the *face* argument.\n        # Calculation:\n        # Center pos of the target surface +/- Half of the current's thickness +/- Additional gap\n        f = face.lower()\n\n        # Z direction\n        if f == \"top\":\n            dest_z = t_box.max.Z + (s_h / 2) + offset\n        elif f == \"bottom\":\n            dest_z = t_box.min.Z - (s_h / 2) - offset\n\n        # X direction\n        elif f == \"right\":\n            dest_x = t_box.max.X + (s_w / 2) + offset\n        elif f == \"left\":\n            dest_x = t_box.min.X - (s_w / 2) - offset\n\n        # Y direction\n        elif f == \"back\":\n            dest_y = t_box.max.Y + (s_d / 2) + offset\n        elif f == \"front\":\n            dest_y = t_box.min.Y - (s_d / 2) - offset\n        else:\n            raise ValueError(f\"\u274c Unknown face: {face}. Use top/bottom/left/right/front/back\")\n\n        # Calculate the displacement vector (target.center() - current.center())\n        # Necessary!\n        curr_x = s_box.center().X\n        curr_y = s_box.center().Y\n        curr_z = s_box.center().Z\n\n        dx = dest_x - curr_x\n        dy = dest_y - curr_y\n        dz = dest_z - curr_z\n\n        if TYPE_CHECKING:\n            assert isinstance(self, Entity)\n        return self.move(dx, dy, dz)\n\n    # Syntactic Sugar for AI agents\n\n    def on_top_of(self, target, offset=0):\n        return self.align(target, \"top\", offset)\n\n    def under(self, target, offset=0):\n        return self.align(target, \"bottom\", offset)\n\n    def right_of(self, target, offset=0):\n        return self.align(target, \"right\", offset)\n\n    def left_of(self, target, offset=0):\n        return self.align(target, \"left\", offset)\n\n    def in_front_of(self, target, offset=0):\n        return self.align(target, \"front\", offset)\n\n    def behind(self, target, offset=0):\n        return self.align(target, \"back\", offset)\n</code></pre>"},{"location":"api/#igniscad.AlignmentMixin.bbox","title":"<code>bbox</code>  <code>property</code>","text":"<p>Grabbing the bounding box of the entity.</p>"},{"location":"api/#igniscad.AlignmentMixin.radius","title":"<code>radius</code>  <code>property</code>","text":"<p>Estimate the radius of the entity(only for spheres and/or cylinders).</p>"},{"location":"api/#igniscad.AlignmentMixin.right","title":"<code>right</code>  <code>property</code>","text":"<p>Grabbing the maximum X pos.</p>"},{"location":"api/#igniscad.AlignmentMixin.top","title":"<code>top</code>  <code>property</code>","text":"<p>Grabbing the Z pos of the center point of the top surface of the entity.</p>"},{"location":"api/#igniscad.AlignmentMixin.align","title":"<code>align(target, face='top', offset=0)</code>","text":"<p>Snap the current Entity to a specified face of the target.</p> Calculation <p>Center pos of the target surface + Half of the current's thickness + Additional gap</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Entity</code> <p>The target Entity</p> required <code>face</code> <code>str</code> <p>\"top\", \"bottom\", \"left\", \"right\", \"front\", \"back\"</p> <code>'top'</code> <code>offset</code> <code>float</code> <p>Addition gap between the current and the target. (A positive number refers to a gap and a negative number refers to an embedding.)</p> <code>0</code> Source code in <code>src/igniscad/mixins.py</code> <pre><code>def align(self, target, face=\"top\", offset=0):\n    \"\"\"\n    *Snap* the current Entity to a specified face of the target.\n\n    Calculation:\n        Center pos of the target surface + Half of the current's thickness + Additional gap\n\n    Args:\n        target (Entity): The target Entity\n        face (str): \"top\", \"bottom\", \"left\", \"right\", \"front\", \"back\"\n        offset (float): Addition gap between the current and the target.\n            (A positive number refers to a gap and a negative number refers to an embedding.)\n    \"\"\"\n\n    # Grabbing the bounding box.\n    t_box = target.bbox  # Target Bounding Box\n    s_box = self.bbox  # Self Bounding Box (Current)\n\n    # The default goal pos is target.center().\n    dest_x = t_box.center().X\n    dest_y = t_box.center().Y\n    dest_z = t_box.center().Z\n\n    # Own size (Width, Depth, Height)\n    s_w = s_box.size.X\n    s_d = s_box.size.Y\n    s_h = s_box.size.Z\n\n    # Adjust the goal pos according to the *face* argument.\n    # Calculation:\n    # Center pos of the target surface +/- Half of the current's thickness +/- Additional gap\n    f = face.lower()\n\n    # Z direction\n    if f == \"top\":\n        dest_z = t_box.max.Z + (s_h / 2) + offset\n    elif f == \"bottom\":\n        dest_z = t_box.min.Z - (s_h / 2) - offset\n\n    # X direction\n    elif f == \"right\":\n        dest_x = t_box.max.X + (s_w / 2) + offset\n    elif f == \"left\":\n        dest_x = t_box.min.X - (s_w / 2) - offset\n\n    # Y direction\n    elif f == \"back\":\n        dest_y = t_box.max.Y + (s_d / 2) + offset\n    elif f == \"front\":\n        dest_y = t_box.min.Y - (s_d / 2) - offset\n    else:\n        raise ValueError(f\"\u274c Unknown face: {face}. Use top/bottom/left/right/front/back\")\n\n    # Calculate the displacement vector (target.center() - current.center())\n    # Necessary!\n    curr_x = s_box.center().X\n    curr_y = s_box.center().Y\n    curr_z = s_box.center().Z\n\n    dx = dest_x - curr_x\n    dy = dest_y - curr_y\n    dz = dest_z - curr_z\n\n    if TYPE_CHECKING:\n        assert isinstance(self, Entity)\n    return self.move(dx, dy, dz)\n</code></pre>"},{"location":"api/#igniscad.Axis","title":"<code>Axis</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enumeration for the three Cartesian axes (X, Y, Z).</p> Source code in <code>src/igniscad/selectors.py</code> <pre><code>class Axis(Enum):\n    \"\"\"An enumeration for the three Cartesian axes (X, Y, Z).\"\"\"\n    X = \"X\"\n    Y = \"Y\"\n    Z = \"Z\"\n</code></pre>"},{"location":"api/#igniscad.BaseContainer","title":"<code>BaseContainer</code>","text":"<p>               Bases: <code>Entity</code></p> <p>The base class of all containers. Supports the context manager syntax and overrides the \"&lt;&lt;\" operator to capture models.</p> Source code in <code>src/igniscad/containers.py</code> <pre><code>class BaseContainer(Entity):\n    \"\"\"\n    The base class of all containers.\n    Supports the context manager syntax and overrides the \"&lt;&lt;\" operator to capture models.\n    \"\"\"\n    def __init__(self, name: str):\n        \"\"\"\n        Args:\n            name (str): name of the Group in context registry.\n        \"\"\"\n        super().__init__(part=None, name=name)\n        # Calling transforming functions right after initialization may cause an AttributeError\n        # That is WAI.\n\n    # Context manager for *with* statements.\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.part:\n            self.part.label = self.name  # names as labels\n        return\n\n    def __lshift__(self, other):\n        \"\"\"\n        Override the \"&lt;&lt;\" operator.\n        Must be inherited in subclasses.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/#igniscad.BaseContainer.__init__","title":"<code>__init__(name)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the Group in context registry.</p> required Source code in <code>src/igniscad/containers.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"\n    Args:\n        name (str): name of the Group in context registry.\n    \"\"\"\n    super().__init__(part=None, name=name)\n</code></pre>"},{"location":"api/#igniscad.BaseContainer.__lshift__","title":"<code>__lshift__(other)</code>","text":"<p>Override the \"&lt;&lt;\" operator. Must be inherited in subclasses.</p> Source code in <code>src/igniscad/containers.py</code> <pre><code>def __lshift__(self, other):\n    \"\"\"\n    Override the \"&lt;&lt;\" operator.\n    Must be inherited in subclasses.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#igniscad.Entity","title":"<code>Entity</code>","text":"<p>               Bases: <code>AlignmentMixin</code>, <code>ModificationMixin</code>, <code>EntitySelectorMixin</code></p> <p>A base class for every wrapped build123d objects. The original build123d objects can be called with entity.part .</p> Source code in <code>src/igniscad/core.py</code> <pre><code>class Entity(AlignmentMixin, ModificationMixin, EntitySelectorMixin):\n    \"\"\"\n    A base class for every wrapped build123d objects.\n    The original build123d objects can be called with entity.part .\n    \"\"\"\n    def __init__(self, part: Union[bd.BasePartObject, bd.BaseSketchObject, bd.Part, bd.Face, bd.Shape] | None, name=None, tags=None):\n        self.part = part\n        self.name = name\n        self.tags = defaultdict(list)\n        if tags:\n            self.tags.update(tags)\n\n    def get_by_tag(self, tag: str):\n        \"\"\"\n        Get a selector for objects with a given tag.\n        \"\"\"\n        from igniscad.selectors import Selector\n        items = self.tags.get(tag, [])\n        return Selector(items, parent=self)\n\n    # Transition logic\n    def move(self, x=0, y=0, z=0):\n        \"\"\"\n        Move the entity to a specific position.\n        \"\"\"\n        new_part = self.wrap_result(self.part.moved(bd.Location((x, y, z))))\n        return self.__class__(new_part, self.name, self.tags)\n\n    def rotate(self, x=0, y=0, z=0):\n        \"\"\"\n        Rotate the entity to a specific angle and position.\n        \"\"\"\n        p = self.part\n        if x: p = p.rotate(bd.Axis.X, x)\n        if y: p = p.rotate(bd.Axis.Y, y)\n        if z: p = p.rotate(bd.Axis.Z, z)\n        return self.__class__(p, self.name, self.tags)\n\n    # Set-like operations\n    @staticmethod\n    def wrap_result(res):\n        \"\"\"\n        Inner helper function to wrap the result into a *single* build123d object.\n        The *show()* function require a single Compound or Solid object to save the .stl file.\n        \"\"\"\n        if not isinstance(res, (bd.Compound, bd.Solid, bd.Shell)):\n            res = bd.Compound(res)\n        return res\n\n    # Overriding the operators.\n    def __sub__(self, other):\n        return self.__class__(bd.Part(self.wrap_result(self.part - other.part)))\n\n    def __add__(self, other):\n        return self.__class__(bd.Part(self.wrap_result(self.part + other.part)))\n\n    def __and__(self, other):\n        return self.__class__(bd.Part(self.wrap_result(self.part &amp; other.part)))\n</code></pre>"},{"location":"api/#igniscad.Entity.get_by_tag","title":"<code>get_by_tag(tag)</code>","text":"<p>Get a selector for objects with a given tag.</p> Source code in <code>src/igniscad/core.py</code> <pre><code>def get_by_tag(self, tag: str):\n    \"\"\"\n    Get a selector for objects with a given tag.\n    \"\"\"\n    from igniscad.selectors import Selector\n    items = self.tags.get(tag, [])\n    return Selector(items, parent=self)\n</code></pre>"},{"location":"api/#igniscad.Entity.move","title":"<code>move(x=0, y=0, z=0)</code>","text":"<p>Move the entity to a specific position.</p> Source code in <code>src/igniscad/core.py</code> <pre><code>def move(self, x=0, y=0, z=0):\n    \"\"\"\n    Move the entity to a specific position.\n    \"\"\"\n    new_part = self.wrap_result(self.part.moved(bd.Location((x, y, z))))\n    return self.__class__(new_part, self.name, self.tags)\n</code></pre>"},{"location":"api/#igniscad.Entity.rotate","title":"<code>rotate(x=0, y=0, z=0)</code>","text":"<p>Rotate the entity to a specific angle and position.</p> Source code in <code>src/igniscad/core.py</code> <pre><code>def rotate(self, x=0, y=0, z=0):\n    \"\"\"\n    Rotate the entity to a specific angle and position.\n    \"\"\"\n    p = self.part\n    if x: p = p.rotate(bd.Axis.X, x)\n    if y: p = p.rotate(bd.Axis.Y, y)\n    if z: p = p.rotate(bd.Axis.Z, z)\n    return self.__class__(p, self.name, self.tags)\n</code></pre>"},{"location":"api/#igniscad.Entity.wrap_result","title":"<code>wrap_result(res)</code>  <code>staticmethod</code>","text":"<p>Inner helper function to wrap the result into a single build123d object. The show() function require a single Compound or Solid object to save the .stl file.</p> Source code in <code>src/igniscad/core.py</code> <pre><code>@staticmethod\ndef wrap_result(res):\n    \"\"\"\n    Inner helper function to wrap the result into a *single* build123d object.\n    The *show()* function require a single Compound or Solid object to save the .stl file.\n    \"\"\"\n    if not isinstance(res, (bd.Compound, bd.Solid, bd.Shell)):\n        res = bd.Compound(res)\n    return res\n</code></pre>"},{"location":"api/#igniscad.EntitySelectorMixin","title":"<code>EntitySelectorMixin</code>","text":"<p>A mixin for the Entity class that provides methods to initiate selections.</p> <p>This mixin adds the .faces(), .edges(), and .vertices() methods to the Entity class, which are the entry points for the fluent selection API.</p> Source code in <code>src/igniscad/mixins.py</code> <pre><code>class EntitySelectorMixin:\n    \"\"\"\n    A mixin for the Entity class that provides methods to initiate selections.\n\n    This mixin adds the .faces(), .edges(), and .vertices() methods to the\n    Entity class, which are the entry points for the fluent selection API.\n    \"\"\"\n    def faces(self) -&gt; FaceSelector:\n        \"\"\"Selects all faces of the entity.\n\n        This method retrieves all faces from the underlying build123d part\n        and wraps them in a FaceSelector, enabling chainable filtering and\n        modification.\n\n        Returns:\n            FaceSelector: A selector containing all faces of the entity.\n        \"\"\"\n        if TYPE_CHECKING:\n            assert isinstance(self, Entity)\n        return FaceSelector(self.part.faces(), parent=self)\n\n    def edges(self) -&gt; EdgeSelector:\n        \"\"\"Selects all edges of the entity.\n\n        This method retrieves all edges from the underlying build123d part\n        and wraps them in an EdgeSelector, enabling chainable filtering and\n        modification.\n\n        Returns:\n            EdgeSelector: A selector containing all edges of the entity.\n        \"\"\"\n        if TYPE_CHECKING:\n            assert isinstance(self, Entity)\n        return EdgeSelector(self.part.edges(), parent=self)\n\n    def vertices(self) -&gt; VertexSelector:\n        \"\"\"Selects all vertices of the entity.\n\n        This method retrieves all vertices from the underlying build123d part\n        and wraps them in a VertexSelector, enabling chainable filtering and\n        modification.\n\n        Returns:\n            VertexSelector: A selector containing all vertices of the entity.\n        \"\"\"\n        if TYPE_CHECKING:\n            assert isinstance(self, Entity)\n        return VertexSelector(self.part.vertices(), parent=self)\n</code></pre>"},{"location":"api/#igniscad.EntitySelectorMixin.edges","title":"<code>edges()</code>","text":"<p>Selects all edges of the entity.</p> <p>This method retrieves all edges from the underlying build123d part and wraps them in an EdgeSelector, enabling chainable filtering and modification.</p> <p>Returns:</p> Name Type Description <code>EdgeSelector</code> <code>EdgeSelector</code> <p>A selector containing all edges of the entity.</p> Source code in <code>src/igniscad/mixins.py</code> <pre><code>def edges(self) -&gt; EdgeSelector:\n    \"\"\"Selects all edges of the entity.\n\n    This method retrieves all edges from the underlying build123d part\n    and wraps them in an EdgeSelector, enabling chainable filtering and\n    modification.\n\n    Returns:\n        EdgeSelector: A selector containing all edges of the entity.\n    \"\"\"\n    if TYPE_CHECKING:\n        assert isinstance(self, Entity)\n    return EdgeSelector(self.part.edges(), parent=self)\n</code></pre>"},{"location":"api/#igniscad.EntitySelectorMixin.faces","title":"<code>faces()</code>","text":"<p>Selects all faces of the entity.</p> <p>This method retrieves all faces from the underlying build123d part and wraps them in a FaceSelector, enabling chainable filtering and modification.</p> <p>Returns:</p> Name Type Description <code>FaceSelector</code> <code>FaceSelector</code> <p>A selector containing all faces of the entity.</p> Source code in <code>src/igniscad/mixins.py</code> <pre><code>def faces(self) -&gt; FaceSelector:\n    \"\"\"Selects all faces of the entity.\n\n    This method retrieves all faces from the underlying build123d part\n    and wraps them in a FaceSelector, enabling chainable filtering and\n    modification.\n\n    Returns:\n        FaceSelector: A selector containing all faces of the entity.\n    \"\"\"\n    if TYPE_CHECKING:\n        assert isinstance(self, Entity)\n    return FaceSelector(self.part.faces(), parent=self)\n</code></pre>"},{"location":"api/#igniscad.EntitySelectorMixin.vertices","title":"<code>vertices()</code>","text":"<p>Selects all vertices of the entity.</p> <p>This method retrieves all vertices from the underlying build123d part and wraps them in a VertexSelector, enabling chainable filtering and modification.</p> <p>Returns:</p> Name Type Description <code>VertexSelector</code> <code>VertexSelector</code> <p>A selector containing all vertices of the entity.</p> Source code in <code>src/igniscad/mixins.py</code> <pre><code>def vertices(self) -&gt; VertexSelector:\n    \"\"\"Selects all vertices of the entity.\n\n    This method retrieves all vertices from the underlying build123d part\n    and wraps them in a VertexSelector, enabling chainable filtering and\n    modification.\n\n    Returns:\n        VertexSelector: A selector containing all vertices of the entity.\n    \"\"\"\n    if TYPE_CHECKING:\n        assert isinstance(self, Entity)\n    return VertexSelector(self.part.vertices(), parent=self)\n</code></pre>"},{"location":"api/#igniscad.Group","title":"<code>Group</code>","text":"<p>               Bases: <code>BaseContainer</code></p> <p>Combine multiple entities into a single Group Entity. Support the same context-manager syntax (as Model does). Entities within a group are automatically unioned. The Group object can be moved or aligned like a normal Entity outside the with statements.</p> Source code in <code>src/igniscad/containers.py</code> <pre><code>class Group(BaseContainer):\n    \"\"\"\n    Combine multiple entities into a single Group Entity.\n    Support the same context-manager syntax (as Model does).\n    Entities within a group are automatically unioned.\n    The Group object can be moved or aligned like a normal Entity outside the *with* statements.\n    \"\"\"\n\n    def __init__(self, name=None):\n        \"\"\"\n        Args:\n            name: name of the Group in context registry.\n        \"\"\"\n        super().__init__(name=name)\n\n    def __lshift__(self, other):\n        \"\"\"\n        Override the \"&lt;&lt;\" operator.\n        Usage: group &lt;&lt; Entity(...)\n\n        Every entity added is unioned automatically.\n        \"\"\"\n        if isinstance(other, Entity):\n            if self.part is None:\n                # Initialize a new group with the current part as a basement.\n                self.part = other.part\n            else:\n                # Union the new part with the old parts.\n                self.part += other.part\n        else:\n            raise ValueError(\"\u274c Group implies adding Entity objects (Box, Cylinder, etc.)\")\n\n        return self\n</code></pre>"},{"location":"api/#igniscad.Group.__init__","title":"<code>__init__(name=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <p>name of the Group in context registry.</p> <code>None</code> Source code in <code>src/igniscad/containers.py</code> <pre><code>def __init__(self, name=None):\n    \"\"\"\n    Args:\n        name: name of the Group in context registry.\n    \"\"\"\n    super().__init__(name=name)\n</code></pre>"},{"location":"api/#igniscad.Group.__lshift__","title":"<code>__lshift__(other)</code>","text":"<p>Override the \"&lt;&lt;\" operator. Usage: group &lt;&lt; Entity(...)</p> <p>Every entity added is unioned automatically.</p> Source code in <code>src/igniscad/containers.py</code> <pre><code>def __lshift__(self, other):\n    \"\"\"\n    Override the \"&lt;&lt;\" operator.\n    Usage: group &lt;&lt; Entity(...)\n\n    Every entity added is unioned automatically.\n    \"\"\"\n    if isinstance(other, Entity):\n        if self.part is None:\n            # Initialize a new group with the current part as a basement.\n            self.part = other.part\n        else:\n            # Union the new part with the old parts.\n            self.part += other.part\n    else:\n        raise ValueError(\"\u274c Group implies adding Entity objects (Box, Cylinder, etc.)\")\n\n    return self\n</code></pre>"},{"location":"api/#igniscad.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>BaseContainer</code></p> <p>A context manager to capture generated models(Entity objects).</p> Source code in <code>src/igniscad/containers.py</code> <pre><code>class Model(BaseContainer):\n    \"\"\"\n    A context manager to capture generated models(Entity objects).\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        \"\"\"\n        Args:\n            name (str): name of the Group in context registry.\n        \"\"\"\n        super().__init__(name=name)\n        self.registry = {}\n\n    # Operator overriding\n    def __lshift__(self, other):\n        \"\"\"\n        Override the \"&lt;&lt;\" operator.\n        Usage: model &lt;&lt; Entity(...)\n        \"\"\"\n        if isinstance(other, Entity):\n            self.part = self.part + other.part if self.part else other.part\n            if other.name:\n                self.registry[other.name] = other\n        return self\n\n    # Registry utils\n\n    # Note: advantages of using a registry:\n    # being *disvariabled*\n    # you can define an entity without wrapping them into a variable\n    # variables are easy to be ripped off between different contexts\n    # you can call this entity anywhere through model.f(&lt;entity.name_in_registry&gt;)\n    # you can also edit the registry by yourself, but that's not recommended.\n    def find(self, name: str):\n        \"\"\"\n        To find an Entity by its name in the registry.\n        Args:\n            name (str): Entity name\n        \"\"\"\n        if name in self.registry:\n            return self.registry[name]\n        raise ValueError(f\"\u274c Part '{name}' not found in this model.\")\n\n    def f(self, name: str):\n        return self.find(name)\n</code></pre>"},{"location":"api/#igniscad.Model.__init__","title":"<code>__init__(name)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the Group in context registry.</p> required Source code in <code>src/igniscad/containers.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    \"\"\"\n    Args:\n        name (str): name of the Group in context registry.\n    \"\"\"\n    super().__init__(name=name)\n    self.registry = {}\n</code></pre>"},{"location":"api/#igniscad.Model.__lshift__","title":"<code>__lshift__(other)</code>","text":"<p>Override the \"&lt;&lt;\" operator. Usage: model &lt;&lt; Entity(...)</p> Source code in <code>src/igniscad/containers.py</code> <pre><code>def __lshift__(self, other):\n    \"\"\"\n    Override the \"&lt;&lt;\" operator.\n    Usage: model &lt;&lt; Entity(...)\n    \"\"\"\n    if isinstance(other, Entity):\n        self.part = self.part + other.part if self.part else other.part\n        if other.name:\n            self.registry[other.name] = other\n    return self\n</code></pre>"},{"location":"api/#igniscad.Model.find","title":"<code>find(name)</code>","text":"<p>To find an Entity by its name in the registry. Args:     name (str): Entity name</p> Source code in <code>src/igniscad/containers.py</code> <pre><code>def find(self, name: str):\n    \"\"\"\n    To find an Entity by its name in the registry.\n    Args:\n        name (str): Entity name\n    \"\"\"\n    if name in self.registry:\n        return self.registry[name]\n    raise ValueError(f\"\u274c Part '{name}' not found in this model.\")\n</code></pre>"},{"location":"api/#igniscad.ModificationMixin","title":"<code>ModificationMixin</code>","text":"<p>A mixin of class Entity, specified to perform modification operations.</p> Source code in <code>src/igniscad/mixins.py</code> <pre><code>class ModificationMixin:\n    \"\"\"\n    A mixin of class Entity, specified to perform modification operations.\n    \"\"\"\n    def fillet(self, radius, edges=None):\n        \"\"\"\n        Fillets the edges of the entity.\n\n        Args:\n            radius (float): The radius of the fillet.\n            edges (list, optional): A list of edges to fillet. If None, all edges are filleted. Defaults to None.\n        \"\"\"\n        if TYPE_CHECKING:\n            assert isinstance(self, Entity)\n\n        edges_to_fillet = edges\n        if edges_to_fillet is None:\n            edges_to_fillet = self.part.edges()\n\n        # Convert primitive to a generic Solid by using its .wrapped property\n        part_as_solid = bd.Solid(self.part.wrapped)\n        new_part = part_as_solid.fillet(radius, edge_list=edges_to_fillet)\n        return self.__class__(self.wrap_result(new_part), self.name, self.tags)\n\n    def chamfer(self, distance, edges=None):\n        \"\"\"\n        Chamfers the edges of the entity.\n\n        Args:\n            distance (float): The distance of the chamfer.\n            edges (list, optional): A list of edges to chamfer. If None, all edges are chamfered. Defaults to None.\n        \"\"\"\n        if TYPE_CHECKING:\n            assert isinstance(self, Entity)\n\n        edges_to_chamfer = edges\n        if edges_to_chamfer is None:\n            edges_to_chamfer = self.part.edges()\n\n        # Convert primitive to a generic Solid by using its .wrapped property\n        part_as_solid = bd.Solid(self.part.wrapped)\n        new_part = part_as_solid.chamfer(distance, distance, edge_list=edges_to_chamfer)\n        return self.__class__(self.wrap_result(new_part), self.name, self.tags)\n\n    def shell(self):\n        \"\"\"\n        Creates a shell of the entity.\n        \"\"\"\n        if TYPE_CHECKING:\n            assert isinstance(self, Entity)\n\n        shell_obj = self.part.shell()\n\n        return self.__class__(shell_obj, self.name, self.tags)\n\n    def offset(self, distance, kind=bd.Kind.ARC):\n        \"\"\"\n        Offsets the entity.\n\n        Args:\n            distance (float): The distance to offset.\n            kind (str, optional): The kind of offset to perform. Defaults to 'arc'.\n        \"\"\"\n        if TYPE_CHECKING:\n            assert isinstance(self, Entity)\n\n        try:\n            new_part = bd.offset(self.part, amount=distance, kind=kind)\n        except RuntimeError as e:\n            if \"Unexpected result type\" in str(e):\n                # This error can happen with complex sketches like text, where offsetting\n                # a character results in a shape that build123d doesn't expect.\n                # The workaround is to offset each face of the compound individually\n                # and combine the results, skipping any faces that fail to offset.\n                all_faces = self.part.faces()\n                offset_faces = []\n                for face in all_faces:\n                    try:\n                        # Each face of a text object is a letter.\n                        offset_result = bd.offset(face, amount=distance, kind=kind)\n                        if isinstance(offset_result, bd.Face):\n                            offset_faces.append(offset_result)\n                        elif isinstance(offset_result, bd.Compound):\n                            offset_faces.extend(offset_result.faces())\n                    except RuntimeError:\n                        pass\n\n                if not offset_faces:\n                    raise RuntimeError(\"Offset operation failed for all faces.\") from e\n\n                new_part = bd.Sketch(offset_faces)\n            else:\n                raise e\n\n        return self.__class__(self.wrap_result(new_part), self.name, self.tags)\n</code></pre>"},{"location":"api/#igniscad.ModificationMixin.chamfer","title":"<code>chamfer(distance, edges=None)</code>","text":"<p>Chamfers the edges of the entity.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance of the chamfer.</p> required <code>edges</code> <code>list</code> <p>A list of edges to chamfer. If None, all edges are chamfered. Defaults to None.</p> <code>None</code> Source code in <code>src/igniscad/mixins.py</code> <pre><code>def chamfer(self, distance, edges=None):\n    \"\"\"\n    Chamfers the edges of the entity.\n\n    Args:\n        distance (float): The distance of the chamfer.\n        edges (list, optional): A list of edges to chamfer. If None, all edges are chamfered. Defaults to None.\n    \"\"\"\n    if TYPE_CHECKING:\n        assert isinstance(self, Entity)\n\n    edges_to_chamfer = edges\n    if edges_to_chamfer is None:\n        edges_to_chamfer = self.part.edges()\n\n    # Convert primitive to a generic Solid by using its .wrapped property\n    part_as_solid = bd.Solid(self.part.wrapped)\n    new_part = part_as_solid.chamfer(distance, distance, edge_list=edges_to_chamfer)\n    return self.__class__(self.wrap_result(new_part), self.name, self.tags)\n</code></pre>"},{"location":"api/#igniscad.ModificationMixin.fillet","title":"<code>fillet(radius, edges=None)</code>","text":"<p>Fillets the edges of the entity.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>The radius of the fillet.</p> required <code>edges</code> <code>list</code> <p>A list of edges to fillet. If None, all edges are filleted. Defaults to None.</p> <code>None</code> Source code in <code>src/igniscad/mixins.py</code> <pre><code>def fillet(self, radius, edges=None):\n    \"\"\"\n    Fillets the edges of the entity.\n\n    Args:\n        radius (float): The radius of the fillet.\n        edges (list, optional): A list of edges to fillet. If None, all edges are filleted. Defaults to None.\n    \"\"\"\n    if TYPE_CHECKING:\n        assert isinstance(self, Entity)\n\n    edges_to_fillet = edges\n    if edges_to_fillet is None:\n        edges_to_fillet = self.part.edges()\n\n    # Convert primitive to a generic Solid by using its .wrapped property\n    part_as_solid = bd.Solid(self.part.wrapped)\n    new_part = part_as_solid.fillet(radius, edge_list=edges_to_fillet)\n    return self.__class__(self.wrap_result(new_part), self.name, self.tags)\n</code></pre>"},{"location":"api/#igniscad.ModificationMixin.offset","title":"<code>offset(distance, kind=bd.Kind.ARC)</code>","text":"<p>Offsets the entity.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance to offset.</p> required <code>kind</code> <code>str</code> <p>The kind of offset to perform. Defaults to 'arc'.</p> <code>ARC</code> Source code in <code>src/igniscad/mixins.py</code> <pre><code>def offset(self, distance, kind=bd.Kind.ARC):\n    \"\"\"\n    Offsets the entity.\n\n    Args:\n        distance (float): The distance to offset.\n        kind (str, optional): The kind of offset to perform. Defaults to 'arc'.\n    \"\"\"\n    if TYPE_CHECKING:\n        assert isinstance(self, Entity)\n\n    try:\n        new_part = bd.offset(self.part, amount=distance, kind=kind)\n    except RuntimeError as e:\n        if \"Unexpected result type\" in str(e):\n            # This error can happen with complex sketches like text, where offsetting\n            # a character results in a shape that build123d doesn't expect.\n            # The workaround is to offset each face of the compound individually\n            # and combine the results, skipping any faces that fail to offset.\n            all_faces = self.part.faces()\n            offset_faces = []\n            for face in all_faces:\n                try:\n                    # Each face of a text object is a letter.\n                    offset_result = bd.offset(face, amount=distance, kind=kind)\n                    if isinstance(offset_result, bd.Face):\n                        offset_faces.append(offset_result)\n                    elif isinstance(offset_result, bd.Compound):\n                        offset_faces.extend(offset_result.faces())\n                except RuntimeError:\n                    pass\n\n            if not offset_faces:\n                raise RuntimeError(\"Offset operation failed for all faces.\") from e\n\n            new_part = bd.Sketch(offset_faces)\n        else:\n            raise e\n\n    return self.__class__(self.wrap_result(new_part), self.name, self.tags)\n</code></pre>"},{"location":"api/#igniscad.ModificationMixin.shell","title":"<code>shell()</code>","text":"<p>Creates a shell of the entity.</p> Source code in <code>src/igniscad/mixins.py</code> <pre><code>def shell(self):\n    \"\"\"\n    Creates a shell of the entity.\n    \"\"\"\n    if TYPE_CHECKING:\n        assert isinstance(self, Entity)\n\n    shell_obj = self.part.shell()\n\n    return self.__class__(shell_obj, self.name, self.tags)\n</code></pre>"},{"location":"api/#igniscad.Box","title":"<code>Box(x, y, z, name=None)</code>","text":"<p>Wrapped function for build123d.Box.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate</p> required <code>y</code> <code>float</code> <p>Y coordinate</p> required <code>z</code> <code>float</code> <p>Z coordinate</p> required <code>name</code> <code>str</code> <p>name of the Entity in context registry</p> <code>None</code> Source code in <code>src/igniscad/primitives.py</code> <pre><code>@validate_dimensions(\"x\", \"y\", \"z\")\ndef Box(x: float, y: float, z: float, name: str = None) -&gt; Entity:\n    \"\"\"\n    Wrapped function for build123d.Box.\n\n    Args:\n        x (float): X coordinate\n        y (float): Y coordinate\n        z (float): Z coordinate\n        name (str): name of the Entity in context registry\n    \"\"\"\n    return Entity(bd.Box(x, y, z, align=(bd.Align.CENTER, bd.Align.CENTER, bd.Align.CENTER)), name)\n</code></pre>"},{"location":"api/#igniscad.Circle","title":"<code>Circle(r, name=None)</code>","text":"<p>Creates a 2D circle sketch.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float</code> <p>Radius of the circle.</p> required <code>name</code> <code>str</code> <p>Name of the Entity in the context registry.</p> <code>None</code> Source code in <code>src/igniscad/primitives_2d.py</code> <pre><code>@validate_dimensions(\"r\")\ndef Circle(r: float, name: str = None) -&gt; Entity:\n    \"\"\"\n    Creates a 2D circle sketch.\n\n    Args:\n        r (float): Radius of the circle.\n        name (str): Name of the Entity in the context registry.\n    \"\"\"\n    sketch = bd.Circle(r)\n    return Entity(sketch, name)\n</code></pre>"},{"location":"api/#igniscad.Cone","title":"<code>Cone(bottom_radius, top_radius, h, name=None)</code>","text":"<p>Wrapped function for build123d.Cone.</p> <p>Parameters:</p> Name Type Description Default <code>bottom_radius</code> <code>float</code> <p>bottom radius</p> required <code>top_radius</code> <code>float</code> <p>top radius</p> required <code>h</code> <code>float</code> <p>height</p> required <code>name</code> <code>str</code> <p>name of the Entity in context registry</p> <code>None</code> Source code in <code>src/igniscad/primitives.py</code> <pre><code>@validate_dimensions(\"bottom_radius\", \"top_radius\", \"h\")\ndef Cone(bottom_radius: float, top_radius: float, h: float, name: str = None) -&gt; Entity:\n    \"\"\"\n    Wrapped function for build123d.Cone.\n\n    Args:\n        bottom_radius (float): bottom radius\n        top_radius (float): top radius\n        h (float): height\n        name (str): name of the Entity in context registry\n    \"\"\"\n    return Entity(bd.Cone(bottom_radius=bottom_radius, top_radius=top_radius, height=h, align=(bd.Align.CENTER, bd.Align.CENTER, bd.Align.CENTER)), name)\n</code></pre>"},{"location":"api/#igniscad.CounterBoreHole","title":"<code>CounterBoreHole(radius, cb_radius, cb_depth, height, name=None)</code>","text":"<p>Creates a counter-bore hole shape (for boolean subtraction). AI description: A hole for a socket head cap screw.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Through-hole radius (for the screw shaft)</p> required <code>cb_radius</code> <code>float</code> <p>Counter-bore radius (for the screw head)</p> required <code>cb_depth</code> <code>float</code> <p>Counter-bore depth</p> required <code>height</code> <code>float</code> <p>Total height of the hole</p> required <code>name</code> <code>str</code> <p>Name of the Entity in the context registry</p> <code>None</code> Source code in <code>src/igniscad/primitives.py</code> <pre><code>@validate_dimensions(\"radius\", \"cb_radius\", \"cb_depth\", \"height\")\ndef CounterBoreHole(radius: float, cb_radius: float, cb_depth: float, height: float, name: str = None) -&gt; Entity:\n    \"\"\"\n    Creates a counter-bore hole shape (for boolean subtraction).\n    AI description: A hole for a socket head cap screw.\n\n    Args:\n        radius (float): Through-hole radius (for the screw shaft)\n        cb_radius (float): Counter-bore radius (for the screw head)\n        cb_depth (float): Counter-bore depth\n        height (float): Total height of the hole\n        name (str): Name of the Entity in the context registry\n    \"\"\"\n    # 1. Create the main through-hole shaft and convert to Part\n    shaft_part = bd.Part(bd.Cylinder(radius=radius, height=height, align=(bd.Align.CENTER, bd.Align.CENTER, bd.Align.CENTER)))\n\n    # 2. Create the counter-bore head and convert to Part\n    head_part = bd.Part(bd.Cylinder(radius=cb_radius, height=cb_depth, align=(bd.Align.CENTER, bd.Align.CENTER, bd.Align.CENTER)))\n\n    # 3. Move the head part to align with the top of the shaft\n    head_offset = (height / 2) - (cb_depth / 2)\n    head_moved_part = head_part.locate(bd.Location(bd.Vector(0, 0, head_offset)))\n\n    # 4. Combine the parts\n    combined_part = shaft_part + head_moved_part\n\n    return Entity(combined_part, name)\n</code></pre>"},{"location":"api/#igniscad.CountersinkHole","title":"<code>CountersinkHole(radius, csk_radius, csk_angle, height, name=None)</code>","text":"<p>Creates a countersink hole shape (for boolean subtraction). AI description: A hole for a countersunk screw.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Through-hole radius</p> required <code>csk_radius</code> <code>float</code> <p>Countersink top radius</p> required <code>csk_angle</code> <code>float</code> <p>Countersink angle in degrees (e.g., 82, 90)</p> required <code>height</code> <code>float</code> <p>Total height of the hole</p> required <code>name</code> <code>str</code> <p>Name of the Entity in the context registry</p> <code>None</code> Source code in <code>src/igniscad/primitives.py</code> <pre><code>@validate_dimensions(\"radius\", \"csk_radius\", \"csk_angle\", \"height\")\ndef CountersinkHole(radius: float, csk_radius: float, csk_angle: float, height: float, name: str = None) -&gt; Entity:\n    \"\"\"\n    Creates a countersink hole shape (for boolean subtraction).\n    AI description: A hole for a countersunk screw.\n\n    Args:\n        radius (float): Through-hole radius\n        csk_radius (float): Countersink top radius\n        csk_angle (float): Countersink angle in degrees (e.g., 82, 90)\n        height (float): Total height of the hole\n        name (str): Name of the Entity in the context registry\n    \"\"\"\n    # Calculate countersink depth from the angle and radii\n    csk_depth = (csk_radius - radius) / math.tan(math.radians(csk_angle / 2))\n\n    # 1. Create the main through-hole shaft and convert to Part\n    shaft_part = bd.Part(bd.Cylinder(radius=radius, height=height, align=(bd.Align.CENTER, bd.Align.CENTER, bd.Align.CENTER)))\n\n    # 2. Create the countersink head (a cone) and convert to Part\n    head_part = bd.Part(bd.Cone(bottom_radius=radius, top_radius=csk_radius, height=csk_depth, align=(bd.Align.CENTER, bd.Align.CENTER, bd.Align.CENTER)))\n\n    # 3. Move the head part to align with the top of the shaft\n    head_offset = (height / 2) - (csk_depth / 2)\n    head_moved_part = head_part.locate(bd.Location(bd.Vector(0, 0, head_offset)))\n\n    # 4. Combine the parts\n    combined_part = shaft_part + head_moved_part\n\n    return Entity(combined_part, name)\n</code></pre>"},{"location":"api/#igniscad.Cylinder","title":"<code>Cylinder(r, h, name=None)</code>","text":"<p>Wrapped function for build123d.Cylinder.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float</code> <p>radius</p> required <code>h</code> <code>float</code> <p>height</p> required <code>name</code> <code>str</code> <p>name of the Entity in context registry</p> <code>None</code> Source code in <code>src/igniscad/primitives.py</code> <pre><code>@validate_dimensions(\"r\", \"h\")\ndef Cylinder(r: float, h: float, name: str = None) -&gt; Entity:\n    \"\"\"\n    Wrapped function for build123d.Cylinder.\n\n    Args:\n        r (float): radius\n        h (float): height\n        name (str): name of the Entity in context registry\n    \"\"\"\n    return Entity(bd.Cylinder(radius=r, height=h, align=(bd.Align.CENTER, bd.Align.CENTER, bd.Align.CENTER)), name)\n</code></pre>"},{"location":"api/#igniscad.Extrude","title":"<code>Extrude(sketch, amount, name=None)</code>","text":"<p>Extrudes a 2D sketch into a 3D part.</p> <p>Parameters:</p> Name Type Description Default <code>sketch</code> <code>Entity</code> <p>The 2D sketch entity to extrude.</p> required <code>amount</code> <code>float</code> <p>The extrusion distance.</p> required <code>name</code> <code>str</code> <p>Name of the new 3D Entity.</p> <code>None</code> Source code in <code>src/igniscad/primitives_2d.py</code> <pre><code>@validate_dimensions(\"amount\")\ndef Extrude(sketch: Entity, amount: float, name: str = None) -&gt; Entity:\n    \"\"\"\n    Extrudes a 2D sketch into a 3D part.\n\n    Args:\n        sketch (Entity): The 2D sketch entity to extrude.\n        amount (float): The extrusion distance.\n        name (str): Name of the new 3D Entity.\n    \"\"\"\n    if not isinstance(sketch.part, (bd.Sketch, bd.Face)):\n        raise TypeError(f\"Extrude operation requires a 2D sketch or face, not {type(sketch.part)}.\")\n\n    part = bd.extrude(sketch.part, amount=amount)\n    return Entity(part, name)\n</code></pre>"},{"location":"api/#igniscad.ISO_Hole","title":"<code>ISO_Hole(size, depth, fit='Normal', name=None)</code>","text":"<p>Creates a standard ISO metric screw clearance hole.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>str</code> <p>\"M2\", \"M3\", \"M4\", \"M5\", \"M6\", \"M8\", \"M10\", \"M12\"</p> required <code>depth</code> <code>float</code> <p>Depth of the hole</p> required <code>fit</code> <code>str</code> <p>\"Close\" (tight fit), \"Normal\" (standard), \"Loose\" (clearance)</p> <code>'Normal'</code> <code>name</code> <code>str</code> <p>Name of the Entity in the context registry</p> <code>None</code> Source code in <code>src/igniscad/primitives.py</code> <pre><code>def ISO_Hole(size: str, depth: float, fit: str = \"Normal\", name: str = None) -&gt; Entity:\n    \"\"\"\n    Creates a standard ISO metric screw clearance hole.\n\n    Args:\n        size (str): \"M2\", \"M3\", \"M4\", \"M5\", \"M6\", \"M8\", \"M10\", \"M12\"\n        depth (float): Depth of the hole\n        fit (str): \"Close\" (tight fit), \"Normal\" (standard), \"Loose\" (clearance)\n        name (str): Name of the Entity in the context registry\n    \"\"\"\n    # ISO 273 clearance hole diameters (in mm)\n    specs = {\n        \"M2\": {\"Close\": 2.2, \"Normal\": 2.4, \"Loose\": 2.6},\n        \"M3\": {\"Close\": 3.2, \"Normal\": 3.4, \"Loose\": 3.6},\n        \"M4\": {\"Close\": 4.3, \"Normal\": 4.5, \"Loose\": 4.8},\n        \"M5\": {\"Close\": 5.3, \"Normal\": 5.5, \"Loose\": 5.8},\n        \"M6\": {\"Close\": 6.4, \"Normal\": 6.6, \"Loose\": 7},\n        \"M8\": {\"Close\": 8.4, \"Normal\": 9, \"Loose\": 10},\n        \"M10\": {\"Close\": 10.5, \"Normal\": 11, \"Loose\": 12},\n        \"M12\": {\"Close\": 13, \"Normal\": 13.5, \"Loose\": 14.5},\n    }\n\n    size_upper = size.upper()\n    if size_upper not in specs:\n        raise ValueError(f\"Unsupported ISO hole size: {size}. Supported sizes are: {list(specs.keys())}\")\n    if fit not in specs[size_upper]:\n        raise ValueError(f\"Unsupported fit: {fit}. Supported fits are: {list(specs[size_upper].keys())}\")\n\n    diameter = specs[size_upper][fit]\n    radius = diameter / 2\n\n    return Cylinder(r=radius, h=depth, name=name)\n</code></pre>"},{"location":"api/#igniscad.Loft","title":"<code>Loft(*sketches, name=None)</code>","text":"<p>Creates a 3D part by lofting through a series of 2D sketches.</p> <p>Parameters:</p> Name Type Description Default <code>*sketches</code> <code>Entity</code> <p>A sequence of 2D sketch entities to loft through.</p> <code>()</code> <code>name</code> <code>str</code> <p>Name of the new 3D Entity.</p> <code>None</code> Source code in <code>src/igniscad/primitives_2d.py</code> <pre><code>def Loft(*sketches: Entity, name: str = None) -&gt; Entity:\n    \"\"\"\n    Creates a 3D part by lofting through a series of 2D sketches.\n\n    Args:\n        *sketches (Entity): A sequence of 2D sketch entities to loft through.\n        name (str): Name of the new 3D Entity.\n    \"\"\"\n    profiles = []\n    for sketch in sketches:\n        if not isinstance(sketch.part, (bd.Sketch, bd.Face, bd.Wire)):\n            raise TypeError(\"Loft requires sketches, faces, or wires.\")\n        profiles.append(sketch.part)\n\n    part = bd.loft(sections=profiles)\n    return Entity(part, name)\n</code></pre>"},{"location":"api/#igniscad.Polygon","title":"<code>Polygon(*points, name=None)</code>","text":"<p>Creates a 2D polygon from a list of points.</p> <p>Parameters:</p> Name Type Description Default <code>*points</code> <p>A list of (x, y) tuples representing the vertices of the polygon.</p> <code>()</code> <code>name</code> <code>str</code> <p>Name of the Entity in the context registry.</p> <code>None</code> Source code in <code>src/igniscad/primitives_2d.py</code> <pre><code>@validate_vertices\ndef Polygon(*points, name: str = None) -&gt; Entity:\n    \"\"\"\n    Creates a 2D polygon from a list of points.\n\n    Args:\n        *points: A list of (x, y) tuples representing the vertices of the polygon.\n        name (str): Name of the Entity in the context registry.\n    \"\"\"\n    sketch = bd.Polygon(*points)\n    return Entity(sketch, name)\n</code></pre>"},{"location":"api/#igniscad.Rectangle","title":"<code>Rectangle(x, y, name=None)</code>","text":"<p>Creates a 2D rectangle sketch.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Width of the rectangle.</p> required <code>y</code> <code>float</code> <p>Height of the rectangle.</p> required <code>name</code> <code>str</code> <p>Name of the Entity in the context registry.</p> <code>None</code> Source code in <code>src/igniscad/primitives_2d.py</code> <pre><code>@validate_dimensions(\"x\", \"y\")\ndef Rectangle(x: float, y: float, name: str = None) -&gt; Entity:\n    \"\"\"\n    Creates a 2D rectangle sketch.\n\n    Args:\n        x (float): Width of the rectangle.\n        y (float): Height of the rectangle.\n        name (str): Name of the Entity in the context registry.\n    \"\"\"\n    sketch = bd.Rectangle(x, y)\n    return Entity(sketch, name)\n</code></pre>"},{"location":"api/#igniscad.Revolve","title":"<code>Revolve(sketch, axis=bd.Axis.X, name=None)</code>","text":"<p>Revolves a 2D sketch around an axis to create a 3D part.</p> <p>Parameters:</p> Name Type Description Default <code>sketch</code> <code>Entity</code> <p>The 2D sketch entity to revolve.</p> required <code>axis</code> <code>Axis</code> <p>The axis of revolution. Defaults to X-axis.</p> <code>X</code> <code>name</code> <code>str</code> <p>Name of the new 3D Entity.</p> <code>None</code> Source code in <code>src/igniscad/primitives_2d.py</code> <pre><code>def Revolve(sketch: Entity, axis: bd.Axis = bd.Axis.X, name: str = None) -&gt; Entity:\n    \"\"\"\n    Revolves a 2D sketch around an axis to create a 3D part.\n\n    Args:\n        sketch (Entity): The 2D sketch entity to revolve.\n        axis (bd.Axis): The axis of revolution. Defaults to X-axis.\n        name (str): Name of the new 3D Entity.\n    \"\"\"\n    if not isinstance(sketch.part, (bd.Sketch, bd.Face)):\n        raise TypeError(\"Revolve operation requires a 2D sketch or face.\")\n\n    part = bd.revolve(sketch.part, axis=axis)\n    return Entity(part, name)\n</code></pre>"},{"location":"api/#igniscad.Slot","title":"<code>Slot(w, h, d, name=None)</code>","text":"<p>Wrapped function for a 3D slot.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>slot width on the 2D sketch plane</p> required <code>h</code> <code>float</code> <p>slot height on the 2D sketch plane(diameter)</p> required <code>d</code> <code>float</code> <p>slot depth (extrusion amount)</p> required <code>name</code> <code>str</code> <p>name of the Entity in context registry</p> <code>None</code> Source code in <code>src/igniscad/primitives.py</code> <pre><code>@validate_dimensions(\"w\", \"h\", \"d\")\ndef Slot(w: float, h: float, d: float, name: str = None) -&gt; Entity:\n    \"\"\"\n    Wrapped function for a 3D slot.\n\n    Args:\n        w (float): slot width on the 2D sketch plane\n        h (float): slot height on the 2D sketch plane(diameter)\n        d (float): slot depth (extrusion amount)\n        name (str): name of the Entity in context registry\n    \"\"\"\n    slot_sketch = bd.Sketch(bd.SlotOverall(width=w, height=h / 2))\n    # Extrude in both directions from the sketch plane to center the part\n    part = bd.extrude(slot_sketch, amount=d / 2, both=True)\n\n    return Entity(part, name)\n</code></pre>"},{"location":"api/#igniscad.Sphere","title":"<code>Sphere(r, name=None)</code>","text":"<p>Wrapped function for build123d.Sphere.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float</code> <p>radius</p> required <code>name</code> <code>str</code> <p>name of the Entity in context registry</p> <code>None</code> Source code in <code>src/igniscad/primitives.py</code> <pre><code>@validate_dimensions(\"r\")\ndef Sphere(r: float, name: str = None) -&gt; Entity:\n    \"\"\"\n    Wrapped function for build123d.Sphere.\n\n    Args:\n        r (float): radius\n        name (str): name of the Entity in context registry\n    \"\"\"\n    return Entity(bd.Sphere(radius=r), name)\n</code></pre>"},{"location":"api/#igniscad.Sweep","title":"<code>Sweep(sketch, path, name=None)</code>","text":"<p>Sweeps a 2D sketch along a path to create a 3D part.</p> <p>Parameters:</p> Name Type Description Default <code>sketch</code> <code>Entity</code> <p>The 2D profile sketch.</p> required <code>path</code> <code>Entity</code> <p>The 1D path (e.g., a Line, Spline, or Wire).</p> required <code>name</code> <code>str</code> <p>Name of the new 3D Entity.</p> <code>None</code> Source code in <code>src/igniscad/primitives_2d.py</code> <pre><code>def Sweep(sketch: Entity, path: Entity, name: str = None) -&gt; Entity:\n    \"\"\"\n    Sweeps a 2D sketch along a path to create a 3D part.\n\n    Args:\n        sketch (Entity): The 2D profile sketch.\n        path (Entity): The 1D path (e.g., a Line, Spline, or Wire).\n        name (str): Name of the new 3D Entity.\n    \"\"\"\n    if not isinstance(sketch.part, (bd.Sketch, bd.Face)):\n        raise TypeError(\"Sweep profile must be a 2D sketch or face.\")\n    if not isinstance(path.part, (bd.Edge, bd.Wire)):\n        raise TypeError(\"Sweep path must be an Edge or Wire.\")\n\n    part = bd.sweep(sketch.part, path=path.part)\n    return Entity(part, name)\n</code></pre>"},{"location":"api/#igniscad.Text","title":"<code>Text(txt, font_size, font='Arial', name=None)</code>","text":"<p>Creates a 2D text sketch.</p> <p>Parameters:</p> Name Type Description Default <code>txt</code> <code>str</code> <p>The text to be rendered.</p> required <code>font_size</code> <code>float</code> <p>The size of the font.</p> required <code>font</code> <code>str</code> <p>The name of the font.</p> <code>'Arial'</code> <code>name</code> <code>str</code> <p>Name of the Entity in the context registry.</p> <code>None</code> Source code in <code>src/igniscad/primitives_2d.py</code> <pre><code>@validate_dimensions(\"font_size\")\ndef Text(txt: str, font_size: float, font: str = \"Arial\", name: str = None) -&gt; Entity:\n    \"\"\"\n    Creates a 2D text sketch.\n\n    Args:\n        txt (str): The text to be rendered.\n        font_size (float): The size of the font.\n        font (str): The name of the font.\n        name (str): Name of the Entity in the context registry.\n    \"\"\"\n    sketch = bd.Text(txt, font_size=font_size, font=font)\n    return Entity(sketch, name)\n</code></pre>"},{"location":"api/#igniscad.Torus","title":"<code>Torus(major, minor, name=None)</code>","text":"<p>Wrapped function for build123d.Torus.</p> <p>Parameters:</p> Name Type Description Default <code>major</code> <code>float</code> <p>major radius</p> required <code>minor</code> <code>float</code> <p>minor radius</p> required <code>name</code> <code>str</code> <p>name of the Entity in context registry</p> <code>None</code> Source code in <code>src/igniscad/primitives.py</code> <pre><code>@validate_dimensions(\"major\", \"minor\")\ndef Torus(major: float, minor: float, name: str = None) -&gt; Entity:\n    \"\"\"\n    Wrapped function for build123d.Torus.\n\n    Args:\n        major (float): major radius\n        minor (float): minor radius\n        name (str): name of the Entity in context registry\n    \"\"\"\n    return Entity(bd.Torus(major_radius=major, minor_radius=minor), name)\n</code></pre>"},{"location":"api/#igniscad.Wedge","title":"<code>Wedge(xsize, ysize, zsize, xmax, xmin, ymax, ymin, name=None)</code>","text":"<p>Wrapped function for build123d.Wedge.</p> <p>Parameters:</p> Name Type Description Default <code>xsize</code> <code>float</code> <p>Base width (X)</p> required <code>ysize</code> <code>float</code> <p>Base depth (Y)</p> required <code>zsize</code> <code>float</code> <p>Height (Z)</p> required <code>xmax</code> <code>float</code> <p>X coordinate of the top face end (relative to origin 0)</p> required <code>xmin</code> <code>float</code> <p>X coordinate of the top face start (relative to origin 0)</p> required <code>ymax</code> <code>float</code> <p>Y coordinate of the top face end (mapped to build123d zmax)</p> required <code>ymin</code> <code>float</code> <p>Y coordinate of the top face start (mapped to build123d zmin)</p> required <code>name</code> <code>str</code> <p>name of the Entity in context registry</p> <code>None</code> Note <p>In build123d, the zmax and zmin params control the Y direction, which can be confusing. They are re-mapped to ymax and ymin here for clarity.</p> Source code in <code>src/igniscad/primitives.py</code> <pre><code>@validate_dimensions(\"xsize\", \"ysize\", \"zsize\", \"xmax\", \"xmin\", \"ymax\", \"ymin\")\ndef Wedge(xsize: float, ysize: float, zsize: float, xmax: float, xmin: float, ymax: float, ymin: float,\n          name: str = None) -&gt; Entity:\n    \"\"\"\n    Wrapped function for build123d.Wedge.\n\n    Args:\n        xsize (float): Base width (X)\n        ysize (float): Base depth (Y)\n        zsize (float): Height (Z)\n        xmax (float): X coordinate of the top face end (relative to origin 0)\n        xmin (float): X coordinate of the top face start (relative to origin 0)\n        ymax (float): Y coordinate of the top face end (mapped to build123d zmax)\n        ymin (float): Y coordinate of the top face start (mapped to build123d zmin)\n        name (str): name of the Entity in context registry\n\n    Note:\n        In build123d, the *zmax* and *zmin* params control the Y direction, which can be confusing.\n        They are re-mapped to *ymax* and *ymin* here for clarity.\n    \"\"\"\n    return Entity(bd.Wedge(xsize=xsize, ysize=ysize, zsize=zsize, xmax=xmax, xmin=xmin, zmax=ymax, zmin=ymin), name)\n</code></pre>"},{"location":"api/#igniscad.show","title":"<code>show(model, mode='fallback')</code>","text":"<p>Visualize the specified model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to visualize.</p> required <code>mode</code> <code>Literal['fallback', 'yacv', 'export'] = \"fallback\"</code> <p>The method of visualization. \"Fallback\": to export the file when YACV is unavailable. \"yacv\": to visualize the model via Yet Another CAD Viewer. \"export\": to export the model to a *.stl file.</p> <code>'fallback'</code> Source code in <code>src/igniscad/visualization.py</code> <pre><code>def show(model: Model, mode: Literal['fallback', 'yacv', 'export'] = \"fallback\") -&gt; None:\n    \"\"\"\n    Visualize the specified model.\n\n    Args:\n        model (Model): The model to visualize.\n        mode (Literal['fallback', 'yacv', 'export'] = \"fallback\"): The method of visualization.\n            \"Fallback\": to export the file when YACV is unavailable.\n            \"yacv\": to visualize the model via Yet Another CAD Viewer.\n            \"export\": to export the model to a *.stl file.\n    \"\"\"\n    get_logger(__name__).info(f\"Processing model: {model.name}\")\n    match mode:\n        case \"fallback\":\n            if not _show_yacv_model(model, force=False):\n                get_logger(__name__).warning(\"Viewer not available. Exporting to disk...\")\n                _export_stl_file(model)\n        case \"yacv\":\n            _show_yacv_model(model, force=True)\n        case \"export\":\n            _export_stl_file(model)\n\n    return\n</code></pre>"},{"location":"api/#igniscad.validate_dimensions","title":"<code>validate_dimensions(*args_to_check)</code>","text":"<p>Validate whether the specified dimensions are strictly positive (&gt; 0). Raises InfeasibleEntityError if &lt;= 0.</p> <p>Parameters:</p> Name Type Description Default <code>args_to_check</code> <code>str</code> <p>the arguments to validate</p> <code>()</code> Source code in <code>src/igniscad/helpers/validator.py</code> <pre><code>def validate_dimensions(*args_to_check: str):\n    \"\"\"\n    Validate whether the specified dimensions are strictly positive (&gt; 0).\n    Raises InfeasibleEntityError if &lt;= 0.\n\n    Args:\n        args_to_check(str): the arguments to validate\n    \"\"\"\n\n    def decorator(func):\n        sig = inspect.signature(func)\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            bound_args = sig.bind(*args, **kwargs)\n            bound_args.apply_defaults()\n            params = bound_args.arguments\n\n            invalid_params = []\n            for arg_name in args_to_check:\n                if arg_name in params:\n                    val = params[arg_name]\n\n                    if val &lt;= TOLERANCE:\n                        invalid_params.append(f\"{arg_name}={val}\")\n\n            if invalid_params:\n                func_name = func.__name__\n                provided_name = params.get(\"name\")\n\n                display_name = provided_name if provided_name else f\"{func_name}&lt;Pending&gt;\"\n                error_detail = \", \".join(invalid_params)\n                raise InfeasibleEntityError(\n                    entity=SimpleNamespace(name=display_name),\n                    reason=f\"Dimensions must be positive. Invalid arguments: {error_detail}\"\n                )\n\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"api/#igniscad.validate_vertices","title":"<code>validate_vertices(arg_name='points', min_points=3)</code>","text":"<p>Validator for vertices / points. Validate the vertex count and the coincidence (distance between adjacent vertices).</p> <p>Parameters:</p> Name Type Description Default <code>arg_name</code> <code>str</code> <p>the argument to check.</p> <code>'points'</code> <code>min_points</code> <code>int</code> <p>the smallest count of points.</p> <code>3</code> Source code in <code>src/igniscad/helpers/validator.py</code> <pre><code>def validate_vertices(arg_name: str = \"points\", min_points=3):\n    \"\"\"\n    Validator for vertices / points.\n    Validate the vertex count and the coincidence (distance between adjacent vertices).\n\n    Args:\n        arg_name(str): the argument to check.\n        min_points(int): the smallest count of points.\n    \"\"\"\n\n    def decorator(func):\n        sig = inspect.signature(func)\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            bound_args = sig.bind(*args, **kwargs)\n            bound_args.apply_defaults()\n            params = bound_args.arguments\n\n            points = params.get(arg_name)\n\n\n            if not points:\n                raise InfeasibleEntityError(\n                    entity=SimpleNamespace(name=f\"{func.__name__}&lt;Pending&gt;\"),\n                    reason=\"No vertices provided.\"\n                )\n\n            if len(points) &lt; min_points:\n                raise InfeasibleEntityError(\n                    entity=SimpleNamespace(name=f\"{func.__name__}&lt;Pending&gt;\"),\n                    reason=f\"Polygon requires at least {min_points} vertices. Got {len(points)}.\"\n                )\n\n            for i in range(len(points)):\n                p1 = points[i]\n                p2 = points[(i + 1) % len(points)]\n\n                dist = math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n                if dist &lt;= TOLERANCE:\n                    raise InfeasibleEntityError(\n                        entity=SimpleNamespace(name=f\"{func.__name__}&lt;Pending&gt;\"),\n                        reason=(\n                            f\"Vertex {i} {p1} and Vertex {(i + 1) % len(points)} {p2} are too close \"\n                            f\"(distance {dist:.2e} &lt; tolerance {TOLERANCE}). \"\n                            \"This would create a zero-length edge.\"\n                        )\n                    )\n\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"}]}